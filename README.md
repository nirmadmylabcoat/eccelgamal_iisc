# 🔐 ECC-based Cryptographic Primitives in C (OpenSSL)

This repository showcases two essential ECC-based cryptographic protocols written in C using **OpenSSL's BIGNUM and EC libraries**:

1. 🕊️ **Oblivious Transfer (1-out-of-2)** using ECC ElGamal
2. 🔏 **Pedersen Commitments** using EC point arithmetic

---

## 📦 Files

- `eccelgamalot.c`: Simulates a sender-receiver interaction for oblivious transfer using hash-to-point techniques
- `pedersen_commitment.c`: Implements a hiding and binding commitment using random masking and elliptic curve points

---

## 🧠 How They Work

### 🕊️ 1-out-of-2 Oblivious Transfer (`eccelgamalot.c`)

Simulates the core cryptographic idea of 1-out-of-2 OT using ECC:

- Sender generates an **ephemeral key**: `C₁ = kG`
- Receiver generates a **fake public key** from a hash (`hash-to-point`)
- Sender encrypts with this key:  
 \\[
   C_2 = k \cdot \text{PK}_{\text{fake}}
   \\]
- Receiver can't decrypt without `k` or private key knowledge

#### ✅ Security

- Based on **Elliptic Curve Discrete Logarithm Problem (ECDLP)**
- **Brute-force attacks are infeasible** on prime256v1
- Receiver's fake key reveals **no info** about their choice

---

### 🔏 Pedersen Commitment (`pedersen_commitment.c`)

Implements a commitment scheme:

- Commit to a value `m` without revealing it
- Uses a fixed generator `G` and a derived second base `H'`:
  \[
  C = mG + H'
  \]
- H' is generated by hashing a random `r` and mapping to a curve point

#### ✅ Security

- **Hiding**: Random `H'` masks `m`, so no info is leaked
- **Binding**: Based on ECDLP, can't change `m` once committed
- Verifiable by recomputing `C` using revealed `m`

---

## ⚙️ How to Build and Run

### 🛠️ Requirements

- OpenSSL development libraries (`libssl-dev`)
- GCC or Clang

### 🧱 Build

```bash
gcc eccelgamalot.c -o eccelgamalot -lcrypto
gcc pedersen_commitment.c -o pedersen_commitment -lcrypto
